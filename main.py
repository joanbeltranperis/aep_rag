import json
import os
import re

from langchain.prompts import ChatPromptTemplate
from langchain_community.vectorstores import FAISS

from config import RagConfig
from templates.prompts import (
    answer_prompt_template,
    evaluation_prompt_template,
    initial_retrieval_prompt_template,
)
from templates.titles import document_titles
from vector_stores import create_vector_stores


def rag_answer(question: str, config: RagConfig) -> str:
    retrieval_prompt = ChatPromptTemplate.from_template(
        initial_retrieval_prompt_template
    )
    formatted_prompt = retrieval_prompt.format(
        document_titles=document_titles,
        user_question=question,
    )

    print("Retrieving relevant chapters...")
    model_response = config.generative_model.generate_content(formatted_prompt)
    relevant_chapter_numbers = parse_and_validate_chapter_numbers(model_response.text)
    print("Relevant chapters retrieved.")

    if relevant_chapter_numbers is None:
        raise ValueError(
            f"Invalid chapter numbers generated by the LLM: {model_response.text}"
        )

    if not os.path.exists("document_store"):
        document_store = create_vector_stores(config)
    else:
        document_store = FAISS.load_local(
            "document_store",
            embeddings=config.embedding_model,
            allow_dangerous_deserialization=True,
        )

    all_documents = document_store.docstore._dict.values()
    filtered_documents = [
        doc
        for doc in all_documents
        if doc.metadata["chapter_number"] in relevant_chapter_numbers
    ]

    filtered_vector_store = FAISS.from_documents(
        filtered_documents, config.embedding_model
    )

    print("Similarity search retrieval")
    retrieved_documents = filtered_vector_store.similarity_search(
        question,
        k=config.top_k,
    )
    print("Documents retrieved")

    answer_prompt = ChatPromptTemplate.from_template(answer_prompt_template)
    context_text = ""
    for doc in retrieved_documents:
        context_text += f"{doc.metadata}\n{doc.page_content}\n"

    final_prompt = answer_prompt.format(
        question=question,
        context=context_text,
    )
    print("Generating rag answer")
    print(f"Length of prompt: {len(final_prompt)}")
    model_response = config.generative_model.generate_content(final_prompt)
    print("Rag answer generated")

    # debug_log(
    #     {
    #         "query": question,
    #         "answer": model_response.content,
    #         "relevant_documents": relevant_chapter_numbers,
    #         "retrieved_docs": retrieved_documents,
    #     }
    # )

    return model_response.text


def evaluate_answer(
    question: str,
    human_answer: str,
    rag_answer: str,
    config: RagConfig,
) -> dict:
    evaluation_prompt = ChatPromptTemplate.from_template(evaluation_prompt_template)
    formatted_prompt = evaluation_prompt.format(
        question=question,
        human_answer=human_answer,
        rag_answer=rag_answer,
    )

    print("Generating evaluation")
    evaluation_response = config.generative_model.generate_content(formatted_prompt)
    print("Evaluation generated")
    raw_lines = evaluation_response.text.strip().splitlines()
    print(raw_lines)

    cleaned_json_str = clean_json_string(raw_lines)

    try:
        return json.loads(cleaned_json_str)
    except json.JSONDecodeError as e:
        raise ValueError("Failed to parse evaluation JSON") from e


def load_questions(path: str):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def save_questions(data: dict, path: str):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=4)


def main():
    config = RagConfig()

    json_questions = load_questions("random_questions.json")

    for i, json_question in enumerate(json_questions["questions"]):
        i = i + 18
        question = json_question["question"]
        answer = rag_answer(question, config)

        evaluation = evaluate_answer(
            question,
            json_question["human_answer"],
            answer,
            config,
        )
        json_questions["questions"][i]["rag_answer"]["content"] = answer
        json_questions["questions"][i]["rag_answer"]["evaluation"] = evaluation[
            "rag_evaluation"
        ]
        json_questions["questions"][i]["human_answer"]["evaluation"] = evaluation[
            "human_evaluation"
        ]
        print("Saving evaluation")
        save_questions(json_questions, "questions.json")
        print(f"Question {i + 1}/{len(json_questions['questions'])} processed.\n")


def parse_and_validate_chapter_numbers(raw_response: str):
    raw_items = raw_response.strip().replace(" ", "").split(",")

    if len(raw_items) == 0:
        return None

    try:
        chapter_numbers = [int(item) for item in raw_items]
    except (ValueError, TypeError):
        return None

    if not all(1 <= num <= 53 for num in chapter_numbers):
        return None

    return raw_items


def clean_json_string(raw_lines: list[str]) -> str:
    # Remove markdown code block fences
    if raw_lines and raw_lines[0].strip().startswith("```"):
        raw_lines = raw_lines[1:]
    if raw_lines and raw_lines[-1].strip().startswith("```"):
        raw_lines = raw_lines[:-1]

    json_str = "\n".join(raw_lines)

    # Fix common JSON issues

    # 1. Remove trailing commas before closing braces/brackets
    json_str = re.sub(r",\s*(\}|\])", r"\1", json_str)

    # 2. Ensure property names are enclosed in double quotes (optional, JSON should already be fine here)
    # json_str = re.sub(r"(?<=\{|,)\s*([a-zA-Z0-9_]+)\s*:", r'"\1":', json_str)

    # 3. Try to extract the first complete JSON object using brace matching (just in case)
    brace_stack = []
    start_idx = None
    for i, char in enumerate(json_str):
        if char == "{":
            if start_idx is None:
                start_idx = i
            brace_stack.append("{")
        elif char == "}":
            if brace_stack:
                brace_stack.pop()
                if not brace_stack:
                    return json_str[start_idx : i + 1]


if __name__ == "__main__":
    main()
